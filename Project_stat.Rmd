---
title: "Project_stat"
author: "I.Caria, C.De Luca, M.Pernini"
date: "13/06/2022"
output:
  pdf_document: default
  html_document: default
editor_options:
  chunk_output_type: inline
---

## Libraries

```{r message=FALSE, warning=FALSE}

library(ggplot2)
library(tidyverse)
library(leaps)
library(ggcorrplot)
library(regclass)
library(boot)
library(caret)
library(MASS)
library(knitr)
library(corrplot)
library(glmnet)
library(plotly)
library(pROC)

```


## Hotel booking demand dataset

We decided to analyze the *Hotel booking demand dataset* that we load from Kaggle. This dataset contains information about two different kinds of hotel: City Hotel and Resort Hotel. Each observation represents an hotel booking. Both hotels are located in Portugal: the resort hotel at the resort region of Algarve and the city hotel at the city of Lisbon.
The aim of the project is to assess if it is possible, starting from the informations provided by the booking dataset, to predict how likely is that a customer who booked a room will cancel the reservation. This can allow a hotel to plan how many staff are needed, how much food to buy, or, more in general, if it is worth (and to what extent) to engage in overselling in order to fill all available rooms. To achieve this result a prior explanatory analysis is required.
Most of the work deals with analysis and detailed description of the main features with respect to the variable “is_canceled”,  but we decided at the beginning to take a more general look on the whole set of data, in order to have a broader view of the main informations provided by the dataset.


```{r}
# Load the dataset

hotel_bookings <- read.csv("hotel_bookings.csv", na.strings="NULL")
View(hotel_bookings)
```


# Dataset Pre-Processing

The dataset contains 32 variables describing 119390 observations.

In the following lines a detailed description of the variables in alphabetical order is provided:

ADR: the Average Daily Rate, which is the rate obtained by dividing the sum of all lodging transaction by the total number of staying nights;
Adults: the number of adults
Agent: ID of the travel agency that made the booking
ArrivalDateDayOfMonth : Day of the month of the arrival date
ArrivalDateMonth : Month of arrival date with 12 categories: “January” to “December”
ArrivalDateWeekNumber : Week number of the arrival date
ArrivalDateYear : Year of arrival date
AssignedRoomType :  Code for the type of room assigned to the booking. Code is presented instead of designation for anonymity reasons
Babies :  Number of babies
BookingChanges :  Number of changes/amendments made to the booking from the moment the booking was entered on the PMS until the moment of check-in or cancellation
Children : Number of children
Company :  ID of the company/entity that made the booking or responsible for paying the
booking. ID is presented instead of designation for anonymity reasons
Country : Country of origin. Categories are represented in the ISO 3155–3:2013 format
CustomerType :  Type of booking, assuming one of four categories:
  - Contract : when the booking has an allotment or other type of contract associated to it;
  - Group : when the booking is associated to a group;
  - Transient : when the booking is not part of a group or contract, and is not associated to other transient booking;
  - Transient-party : when the booking is transient, but is associated to at least other transient booking
DaysInWaitingList : Number of days the booking was in the waiting list before it was confirmed to the customer
DepositType : Indication on if the customer made a deposit to guarantee the booking. This
variable can assume three categories:
  - No Deposit : no deposit was made;
  - Non Refund : a deposit was made in the value of the total stay cost;
  - Refundable : a deposit was made with a value under the total cost of stay
DistributionChannel : Booking distribution channel. The term “TA” means “Travel Agents” and “TO” means “Tour Operators”
IsCanceled : Value indicating if the booking was canceled (1) or not (0)
IsRepeatedGuest : Value indicating if the booking name was from a repeated guest (1) or not (0)
LeadTime : Number of days that elapsed between the entering date of the booking into the
PMS and the arrival date
MarketSegment : Market segment designation. In categories, the term “TA” means “Travel Agents” and “TO” means “Tour Operators”
Meal : Type of meal booked. Categories are presented in standard hospitality meal
packages:
  - Undefined/SC : no meal package;
  - BB : Bed & Breakfast;
  - HB : Half board (breakfast and one other meal – usually dinner);
  - FB : Full board (breakfast, lunch and dinner)
PreviousBookingsNotCanceled :  Number of previous bookings not cancelled by the customer prior to the current booking
PreviousCancellations : Number of previous bookings that were cancelled by the customer prior to the current booking
RequiredCardParkingSpaces : Number of car parking spaces required by the customer
ReservationStatus :  Reservation last status, assuming one of three categories:
  - Canceled : booking was canceled by the customer;
  - Check-Out : customer has checked in but already departed;
  - No-Show : customer did not check-in and did inform the hotel of the reason why
ReservationStatusDate : Date at which the last status was set
ReservedRoomType : Code of room type reserved. Code is presented instead of designation for anonymity reasons
StaysInWeekendNights :  Number of weekend nights (Saturday or Sunday) the guest stayed or booked to stay at the hotel
StaysInWeekNights : Number of week nights (Monday to Friday) the guest stayed or booked to stay at the hotel
TotalOfSpecialRequests : Number of special requests made by the customer (e.g. twin bed or high floor)


```{r}
# First look to the dataset

glimpse(hotel_bookings)

```

As we can see from the code above, there are many character variables that we converted into factors. Furthermore, we noticed that some categorical variables like *children* were numeric, so we converted them.

```{r warning=FALSE}
# Convert character columns into factors

hotel_bookings_new <- as.data.frame(unclass(hotel_bookings),
                       stringsAsFactors = TRUE)

# Convert binary columns "is_canceled" and "is_repeated_guest" into factor

hotel_bookings_new$is_canceled <- as.factor(hotel_bookings_new$is_canceled)
levels(hotel_bookings_new$is_canceled) <- c(0, 1)

hotel_bookings_new$is_repeated_guest <- as.factor(hotel_bookings_new$is_repeated_guest)
levels(hotel_bookings_new$is_repeated_guest) <- c(0, 1)

# Convert column "arrival_date_year" into factor

hotel_bookings_new$arrival_date_year <- as.factor(hotel_bookings_new$arrival_date_year)
levels(hotel_bookings_new$arrival_date_year) <- c("2015", "2016", "2017")

# Convert column "children" into numeric

hotel_bookings_new$children <- as.numeric(as.character(hotel_bookings_new$children))

# Convert column "reservation status date" into date

hotel_bookings_new$reservation_status_date <- as.Date(
  hotel_bookings_new$reservation_status_date, format = "%Y-%m-%d")
```

The dataset provides two different variables for the stay: *stays_in_weekend_nights* and *stays_in_week_nights*. We decided to add the sum of these two variables as a new variable *total_stays* for ease of analyses.

```{r}
# New column for total stays

hotel_bookings_new=hotel_bookings_new%>%
  mutate(total_stays=(stays_in_week_nights + stays_in_weekend_nights) )
```

### Missing values

```{r}

colSums(is.na(hotel_bookings_new))[colSums(is.na(hotel_bookings_new))>0]
```

Since there are only 4 Nan values for the variable *children*, we decided to replace them with the value 0.
The variables *agent* and *company* have too many Nan values, therefore we removed them. We left untouched the variable *country* because we did not use it in our models.

```{r}
# Replacing missing values in children column from the corresponding babies column

n_children <- length(hotel_bookings_new$children)
for (i in 1:n_children) {
  if (is.na(hotel_bookings_new$children[i]))
    hotel_bookings_new$children[i] <- 0
}

# Remove columns "agent" and "company"

index_agent <- which(colnames(hotel_bookings_new)=="agent")
index_company <- which(colnames(hotel_bookings_new)=="company")
hotel_bookings_new = hotel_bookings_new[-c(index_agent, index_company)]

```

At the end of the pre-processing, we obtained the following dataset:

```{r echo=FALSE}
# Summary

summary(hotel_bookings_new)
```

# EDA

The dataset is made of two original datasets with hotel demand data. One of the hotels is a City Hotel and the other one is a Resort Hotel. The first thing to notice is that data are quite unbalanced and there are 79330 observations for the former and 40060 for the latter.

```{r}
# Hotel donut plot

df_hotel <- as.data.frame(hotel_bookings_new[, c("hotel")])
df_hotel <- as.data.frame(lapply(df_hotel, function(x) as.data.frame(table(x))))

colnames(df_hotel) <- c("hotel", "frequency")

colors_donut <- c('rgb((119,51,68))','rgb((227,181,164))') 

fig_hotel <- df_hotel %>% plot_ly(labels = ~hotel, values = ~frequency, 
                                  marker = list(colors = colors_donut,
                                  line = list(color = '#FFFFFF', width = 1)))
fig_hotel <- fig_hotel %>% add_pie(hole = 0.6)
fig_hotel <- fig_hotel %>% layout(title = "Total number of booking for each hotel",  
                      showlegend = T,
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
fig_hotel

```


Both hotels are located in Portugal; this is the reason why most of the guests come from Portugal, as we can see from the map plot below:

```{r}
# Country plot

df_country <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0, c("country")])
df_country <- as.data.frame(lapply(df_country, function(x) as.data.frame(table(x))))
colnames(df_country) <- c('country', 'frequency')

# we used log-scale to see better the different number of guests for each country
fig_country <- plot_ly(df_country, type='choropleth', locations=df_country$country, 
                       z=log(df_country$frequency+1), colorscale = 'Viridis' )
fig_country <- fig_country %>% layout(title = "Country plot")
fig_country
```

The following plot points out the difference between the two kind of hotels, since most of the reservations related to the City Hotel last approximately 2-3 nights, while in case of the Resort Hotel the same pattern is still observed, but in the meantime also 7 nights stand out as being a very popular choice among guests. More in general a long stay is very unusual in case of the City Hotel.

```{r warning=FALSE}
# Length of stays in night
ggplot(hotel_bookings_new, aes(x=total_stays, fill = hotel)) + 
  geom_bar(stat = "count", position = position_dodge()) + 
  scale_fill_manual(values=c("#EF7365", "#FBD26C"),
    name = "Hotel",
    breaks = c("City Hotel", "Resort Hotel"),
    labels = c("City Hotel", "Resort Hotel")
  ) +
  labs(title = "Length of Stay",
       x = "Number of Nights",
       y = "Count") + xlim(0,20) + 
  theme_bw()

```


The dataset comprehends observations from three years, between the 1st of July of 2015 and the 31st of August 2017, including bookings that effectively arrived and bookings that were canceled. Another information provided by the dataset is the month of arrival, which allows us to take a look at the pattern of the booking curves month by month.
We first made the plot, for each year, of total bookings by month of arrival date, separating the two types of hotels.


```{r}
# Total bookings for each hotel by month (year: 2015)

df_months_City_2015 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='City Hotel' 
              & hotel_bookings_new$arrival_date_year==2015, c( "arrival_date_month")])

df_months_Resort_2015 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='Resort Hotel'
              & hotel_bookings_new$arrival_date_year==2015, c( "arrival_date_month")])

df_months_City_2015 <- as.data.frame(lapply(df_months_City_2015, function(x) 
  as.data.frame(table(x))))

df_months_Resort_2015 <- as.data.frame(lapply(df_months_Resort_2015, function(x) 
  as.data.frame(table(x))))

colnames(df_months_City_2015) <- c("arrival_date_month_City", "frequency_City" )

colnames(df_months_Resort_2015) <- c("arrival_date_month_Resort", "frequency_Resort")

df_months_City_2015$arrival_date_month_City <- factor(df_months_City_2015$arrival_date_month_City, 
            levels = c("January", "February", "March","April", "May", "June", "July", 
                       "August", "September", "October", "November", "December"))

df_months_Resort_2015$arrival_date_month_Resort <- factor(
            df_months_Resort_2015$arrival_date_month_Resort, 
            levels = c("January", "February", "March","April", "May", "June", "July", 
                       "August", "September", "October", "November", "December"))


fig_months_2015 <- plot_ly()

fig_months_2015 <- fig_months_2015 %>% add_lines(data=df_months_City_2015, 
                   x = ~arrival_date_month_City, y = ~frequency_City, name = 'City Hotel', 
                   type = 'scatter', mode = 'lines', 
                   line = list(color = 'rgb((239,115,101))', width = 4))

fig_months_2015 <- fig_months_2015 %>% add_lines(data=df_months_Resort_2015, 
                   x = ~arrival_date_month_Resort, y = ~frequency_Resort, 
                   name = 'Resort Hotel', type = 'scatter', mode = 'lines', 
                   line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_months_2015 <- fig_months_2015 %>% layout(
         title = "2015 - Total bookings for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total bookings"))

fig_months_2015

```

```{r}

# Total bookings for each hotel by month (year: 2016)

df_months_City_2016 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='City Hotel' 
                                     & hotel_bookings_new$arrival_date_year==2016, 
                                     c( "arrival_date_month")])

df_months_Resort_2016 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='Resort Hotel'
                                       & hotel_bookings_new$arrival_date_year==2016, 
                                       c( "arrival_date_month")])

df_months_City_2016 <- as.data.frame(lapply(df_months_City_2016, 
                                            function(x) as.data.frame(table(x))))

df_months_Resort_2016 <- as.data.frame(lapply(df_months_Resort_2016, 
                                              function(x) as.data.frame(table(x))))

colnames(df_months_City_2016) <- c("arrival_date_month_City", "frequency_City" )

colnames(df_months_Resort_2016) <- c("arrival_date_month_Resort", "frequency_Resort")

df_months_City_2016$arrival_date_month_City <- factor(
         df_months_City_2016$arrival_date_month_City, 
         levels = c("January", "February", "March","April", "May", "June", "July", 
                    "August", "September", "October", "November", "December"))

df_months_Resort_2016$arrival_date_month_Resort <- factor(
         df_months_Resort_2016$arrival_date_month_Resort, 
         levels = c("January", "February", "March","April", "May", "June", "July", 
                    "August", "September", "October", "November", "December"))


fig_months_2016 <- plot_ly()

fig_months_2016 <- fig_months_2016 %>% add_lines(data=df_months_City_2016, 
                       x = ~arrival_date_month_City, y = ~frequency_City, 
                       name = 'City Hotel', type = 'scatter', mode = 'lines', 
                       line = list(color = 'rgb((239,115,101))', width = 4))

fig_months_2016 <- fig_months_2016 %>% add_lines(data=df_months_Resort_2016, 
                       x = ~arrival_date_month_Resort, y = ~frequency_Resort, 
                       name = 'Resort Hotel', type = 'scatter', mode = 'lines', 
                       line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_months_2016 <- fig_months_2016 %>% layout(
         title = "2016 - Total bookings for each hotel by month of arrival date",
         xaxis = list(title = "Months",tickangle = -45),
         yaxis = list (title = "Total bookings"))

fig_months_2016
```

```{r}


# Total bookings for each hotel by month (year: 2017)

df_months_City_2017 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='City Hotel' 
                                      & hotel_bookings_new$arrival_date_year==2017, 
                                      c( "arrival_date_month")])

df_months_Resort_2017 <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='Resort Hotel'
                                        & hotel_bookings_new$arrival_date_year==2017, 
                                        c( "arrival_date_month")])

df_months_City_2017 <- as.data.frame(lapply(df_months_City_2017, 
                                            function(x) as.data.frame(table(x))))

df_months_Resort_2017 <- as.data.frame(lapply(df_months_Resort_2017, 
                                            function(x) as.data.frame(table(x))))

colnames(df_months_City_2017) <- c("arrival_date_month_City", "frequency_City" )

colnames(df_months_Resort_2017) <- c("arrival_date_month_Resort", "frequency_Resort")

df_months_City_2017$arrival_date_month_City <- factor(
         df_months_City_2017$arrival_date_month_City, 
         levels = c("January", "February", "March","April", "May", "June", "July", 
                    "August", "September", "October", "November", "December"))

df_months_Resort_2017$arrival_date_month_Resort <- factor(
         df_months_Resort_2017$arrival_date_month_Resort, 
         levels = c("January", "February", "March","April", "May", "June", "July", 
                    "August", "September", "October", "November", "December"))


fig_months_2017 <- plot_ly()

fig_months_2017 <- fig_months_2017 %>% add_lines(data=df_months_City_2017, 
                      x = ~arrival_date_month_City, y = ~frequency_City, 
                      name = 'City Hotel', type = 'scatter', mode = 'lines', 
                      line = list(color = 'rgb((239,115,101))', width = 4))

fig_months_2017 <- fig_months_2017 %>% add_lines(data=df_months_Resort_2017, 
                      x = ~arrival_date_month_Resort, y = ~frequency_Resort, 
                      name = 'Resort Hotel', type = 'scatter', mode = 'lines', 
                      line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_months_2017 <- fig_months_2017 %>% layout(
         title = "2017 - Total bookings for each hotel by month of arrival date",
         xaxis = list(title = "Months",tickangle = -45),
         yaxis = list (title = "Total bookings"))

fig_months_2017
```


In the plot of 2016 a strange behavior is displayed: in the summertime period we expected to find a high number of bookings, however from the graph we can see a slight decrease. Therefore we decided to make the same kind of plots as before, but analyzing the total number of guests in the hotel over the various months, rather than the total number of reservations. From the plots below, we can clearly see that in the summer period of 2016 there is the highest number of guests present compared to the rest of the year, thus showing in effect that the two hotels host more people between July and August. 


```{r}
# Total guests for each hotel by month (year: 2015)

df_2015_City <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                              & hotel_bookings_new$hotel=='City Hotel' 
                              & hotel_bookings_new$arrival_date_year==2015, 
                              c( "arrival_date_month", "total_stays", "adults", 
                                 "children", "babies")])

df_guests_2015_City <- df_2015_City %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 

df_2015_Resort <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                                & hotel_bookings_new$hotel=='Resort Hotel' 
                                & hotel_bookings_new$arrival_date_year==2015, 
                                c( "arrival_date_month", "total_stays", "adults", 
                                   "children", "babies")])

df_guests_2015_Resort <- df_2015_Resort %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 


df_guests_2015_City$arrival_date_month <- factor(df_guests_2015_City$arrival_date_month, 
                                          levels = c("July", "August", 
                                                     "September", "October", 
                                                     "November", "December"))

df_guests_2015_Resort$arrival_date_month <- factor(df_guests_2015_Resort$arrival_date_month, 
                                            levels = c("July", "August", 
                                                       "September", "October", 
                                                       "November", "December"))


fig_guests_2015 <- plot_ly()

fig_guests_2015 <- fig_guests_2015 %>% add_lines(data=df_guests_2015_City, 
                                                 x = ~arrival_date_month, 
                                                 y = ~guests, name = 'City Hotel', 
                                                 type = 'scatter', mode = 'lines', 
                                                 line = list(color = 'rgb((239,115,101))', 
                                                             width = 4))

fig_guests_2015 <- fig_guests_2015 %>% add_lines(data=df_guests_2015_Resort, 
                                                 x = ~arrival_date_month, 
                                                 y = ~guests, name = 'Resort Hotel', 
                                                 type = 'scatter', mode = 'lines', 
                                                 line = list(color = 'rgb((251,210,108))', 
                                                             width = 4)) 

fig_guests_2015 <- fig_guests_2015 %>% layout(
         title = "2015 - Total guests for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total guests"))

fig_guests_2015

```


```{r}
# Total guests for each hotel by month (year: 2016)

df_2016_City <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                              & hotel_bookings_new$hotel=='City Hotel' 
                              & hotel_bookings_new$arrival_date_year==2016, 
                              c( "arrival_date_month", "total_stays", "adults", 
                                 "children", "babies")])

df_guests_2016_City <- df_2016_City %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 

df_2016_Resort <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                                & hotel_bookings_new$hotel=='Resort Hotel' 
                                & hotel_bookings_new$arrival_date_year==2016, 
                                c( "arrival_date_month", "total_stays", "adults", 
                                   "children", "babies")])

df_guests_2016_Resort <- df_2016_Resort %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 


df_guests_2016_City$arrival_date_month <- factor(df_guests_2016_City$arrival_date_month, 
                    levels = c("January", "February", "March","April", "May", 
                               "June", "July", "August","September", "October", 
                               "November", "December"))

df_guests_2016_Resort$arrival_date_month <- factor(df_guests_2016_Resort$arrival_date_month, 
                      levels = c("January", "February", "March","April", "May", 
                                 "June", "July", "August", "September", "October", 
                                 "November", "December"))


fig_guests_2016 <- plot_ly()

fig_guests_2016 <- fig_guests_2016 %>% add_lines(data=df_guests_2016_City, 
                   x = ~arrival_date_month, y = ~guests, name = 'City Hotel', 
                   type = 'scatter', mode = 'lines', 
                   line = list(color = 'rgb((239,115,101))', width = 4))

fig_guests_2016 <- fig_guests_2016 %>% add_lines(data=df_guests_2016_Resort, 
                   x = ~arrival_date_month, y = ~guests, name = 'Resort Hotel', 
                   type = 'scatter', mode = 'lines', 
                   line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_guests_2016 <- fig_guests_2016 %>% layout(
         title = "2016 - Total guests for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total guests"))

fig_guests_2016
```


```{r}
# Total guests for each hotel by month (year: 2017)

df_2017_City <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                              & hotel_bookings_new$hotel=='City Hotel' 
                              & hotel_bookings_new$arrival_date_year==2017, 
                              c( "arrival_date_month", "total_stays", "adults", 
                                 "children", "babies")])

df_guests_2017_City <- df_2017_City %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 

df_2017_Resort <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 
                                & hotel_bookings_new$hotel=='Resort Hotel' 
                                & hotel_bookings_new$arrival_date_year==2017, 
                                c( "arrival_date_month", "total_stays", "adults", 
                                   "children", "babies")])

df_guests_2017_Resort <- df_2017_Resort %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 


df_guests_2017_City$arrival_date_month <- factor(df_guests_2017_City$arrival_date_month, 
                    levels = c("January", "February", "March","April", "May", 
                               "June", "July", "August"))

df_guests_2017_Resort$arrival_date_month <- factor(
                    df_guests_2017_Resort$arrival_date_month, 
                    levels = c("January", "February", "March","April", "May",
                               "June", "July", "August"))


fig_guests_2017 <- plot_ly()

fig_guests_2017 <- fig_guests_2017 %>% add_lines(data=df_guests_2017_City, 
                      x = ~arrival_date_month, y = ~guests, name = 'City Hotel', 
                      type = 'scatter', mode = 'lines', 
                      line = list(color = 'rgb((239,115,101))', width = 4))

fig_guests_2017 <- fig_guests_2017 %>% add_lines(data=df_guests_2017_Resort, 
                      x = ~arrival_date_month, y = ~guests, name = 'Resort Hotel', 
                      type = 'scatter', mode = 'lines', 
                      line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_guests_2017 <- fig_guests_2017 %>% layout(
         title = "2017 - Total guests for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total guests"))

fig_guests_2017
```

We finally compared also the total bookings and the total guests, considering all the observations. We can notice, looking at the following plots, that the behavior that we observed and analyzed above for the 2016 is not evident.


```{r}
# Total bookings for each hotel by month of arrival date

df_months_City <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='City Hotel', 
                                                   c( "arrival_date_month")])

df_months_Resort <- as.data.frame(hotel_bookings_new[hotel_bookings_new$hotel=='Resort Hotel', 
                                                     c( "arrival_date_month")])

df_months_City <- as.data.frame(lapply(df_months_City, function(x) as.data.frame(table(x))))

df_months_Resort <- as.data.frame(lapply(df_months_Resort, function(x) as.data.frame(table(x))))

colnames(df_months_City) <- c("arrival_date_month_City", "frequency_City" )

colnames(df_months_Resort) <- c("arrival_date_month_Resort", "frequency_Resort")

df_months_City$arrival_date_month_City <- factor(df_months_City$arrival_date_month_City, 
          levels = c("January", "February", "March","April", "May", "June", "July", 
                     "August", "September", "October", "November", "December"))

df_months_Resort$arrival_date_month_Resort <- factor(df_months_Resort$arrival_date_month_Resort, 
          levels = c("January", "February", "March","April", "May", "June", "July", 
                     "August", "September", "October", "November", "December"))


fig_months <- plot_ly()

fig_months <- fig_months %>% add_lines(data=df_months_City, 
                                       x = ~arrival_date_month_City, y = ~frequency_City, 
                                       name = 'City Hotel', type = 'scatter', mode = 'lines', 
                                       line = list(color = 'rgb((239,115,101))', width = 4))

fig_months <- fig_months %>% add_lines(data=df_months_Resort, x = ~arrival_date_month_Resort, 
                                       y = ~frequency_Resort, name = 'Resort Hotel', 
                                       type = 'scatter', mode = 'lines', 
                                       line = list(color = 'rgb((251,210,108))', width = 4)) 

fig_months <- fig_months %>% 
layout(title = "Total bookings for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total bookings"))

fig_months
``` 


```{r}
# Total guests for each hotel by month

df_City <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 & 
                         hotel_bookings_new$hotel=='City Hotel', 
                         c( "arrival_date_month", "total_stays", "adults", 
                            "children", "babies")])

df_guests_City <- df_City %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 

df_Resort <- as.data.frame(hotel_bookings_new[hotel_bookings_new$is_canceled==0 & 
                                              hotel_bookings_new$hotel=='Resort Hotel', 
                                              c( "arrival_date_month", "total_stays", 
                                                 "adults", "children", "babies")])

df_guests_Resort <- df_Resort %>%
  group_by(arrival_date_month) %>%
  summarise(guests = sum(total_stays*(adults+children+babies))) %>%
  ungroup() 


df_guests_City$arrival_date_month <- factor(df_guests_City$arrival_date_month, 
          levels = c("January", "February", "March","April", "May", "June", "July", 
                     "August", "September", "October", "November", "December"))

df_guests_Resort$arrival_date_month <- factor(df_guests_Resort$arrival_date_month, 
          levels = c("January", "February", "March","April", "May", "June", "July", 
                     "August", "September", "October", "November", "December"))


fig_guests <- plot_ly()

fig_guests <- fig_guests %>% add_lines(data=df_guests_City, x = ~arrival_date_month, 
                                       y = ~guests, name = 'City Hotel', 
                                       type = 'scatter', mode = 'lines',
                                       line = list(color = 'rgb((239,115,101))', 
                                                   width = 4))

fig_guests <- fig_guests %>% add_lines(data=df_guests_Resort, x = ~arrival_date_month, 
                                       y = ~guests, name = 'Resort Hotel', 
                                       type = 'scatter', mode = 'lines', 
                                       line = list(color = 'rgb((251,210,108))', 
                                                   width = 4)) 

fig_guests <- fig_guests %>% layout(
         title = "Total guests for each hotel by month of arrival date",
         xaxis = list(title = "Months"),
         yaxis = list (title = "Total guests"))

fig_guests

```

Taking a look at the other variables we spent a few time in the analysis of the features *reserved_room_type* and *assigned_room_type* to understand what are the differences among them. 

```{r}
# Reserved room type table

table_hotel_reserved <- table(hotel_bookings_new$hotel, 
                              hotel_bookings_new$reserved_room_type)
table_hotel_reserved
```

```{r}
# Assigned room type table

table_hotel_assigned <- table(hotel_bookings_new$hotel, 
                              hotel_bookings_new$assigned_room_type)
table_hotel_assigned
```

As we can see from the tables above, there are no city hotel (reserved and assigned) room of type *H* and *L*. Furthermore, looking at the assigned room table, we noticed that there are two room types, *I* for the resort hotel and *K* for the city hotel, which were not present in the reserved room table. 

```{r}
# Reserved room type plot

city_reserved <- table_hotel_reserved[c('City Hotel'),]
resort_reserved <- table_hotel_reserved[c('Resort Hotel'),]
room_type_reserved <- colnames(table_hotel_reserved)

df_reserved <- data.frame(room_type_reserved, city_reserved, resort_reserved)

fig_reserved <- plot_ly(df_reserved, x = ~room_type_reserved, y = ~city_reserved, 
                        type = 'bar', name = 'City Hotel', 
                        marker = list(color = 'rgb(239,115,101)'))
fig_reserved <- fig_reserved %>% add_trace(y = ~resort_reserved, name = 'Resort Hotel', 
                                           marker = list(color='rgb(251,210,108)'))
fig_reserved <- fig_reserved %>% layout(title = "Reserved room type", 
                                        xaxis = list(title = 'room type'), 
                                        yaxis =list(title = 'number of bookings'), 
                                        barmode = 'group')
fig_reserved
```


```{r}
# Assigned room type plot

city_assigned <- table_hotel_assigned[c('City Hotel'),]
resort_assigned <- table_hotel_assigned[c('Resort Hotel'),]
room_type_assigned <- colnames(table_hotel_assigned)

df_assigned <- data.frame(room_type_assigned, city_assigned, resort_assigned)

fig_assigned <- plot_ly(df_assigned, x = ~room_type_assigned, y = ~city_assigned, 
                        type = 'bar', name = 'City Hotel', 
                        marker = list(color = 'rgb(239,115,101)'))
fig_assigned <- fig_assigned %>% add_trace(y = ~resort_assigned, name = 'Resort Hotel', 
                                           marker = list(color='rgb(251,210,108)'))
fig_assigned <- fig_assigned %>% layout(title = "Assigned room type", 
                                        xaxis = list(title = 'room type'), 
                                        yaxis =list(title = 'number of bookings'), 
                                        barmode = 'group')
fig_assigned
```

We want now to focus our analysis on the variable *is_canceled*. We first notice that the two classes are quite unbalanced:

```{r}
table(hotel_bookings_new$is_canceled)
```


This can be easily seen also on a donut plot:


```{r warning=FALSE}
# Cancellations donut plot
df_canc <- as.data.frame(hotel_bookings_new[, c("is_canceled")])
df_canc <- as.data.frame(lapply(df_canc, function(x) as.data.frame(table(x))))
colnames(df_canc) <- c("is_canceled", "frequency")
df_canc
colors_donut_canc <- c('rgb(127,216,190)','rgb(216,127,153)') 
fig_canc <- df_canc %>% plot_ly(labels = c('not canceled','canceled' ), values = ~frequency, 
                                  marker = list(colors = colors_donut_canc,
                                  line = list(color = '#FFFFFF', width = 1)))
fig_canc <- fig_canc %>% add_pie(hole = 0.6)
fig_canc <- fig_canc %>% layout(title = "Total number of canceled and not canceled bookings",  
                      showlegend = T,
                      xaxis = list(showgrid = FALSE, zeroline = FALSE,
                                   showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE,
                                   showticklabels = FALSE))
fig_canc
```


The following boxplot shows how cancelations in City and Resort hotel are related to lead_time. We remind here that lead time is the time that elapsed between the day when the booking was made and the actual day of checking-in. We can see that that the median on lead time from cancelled and not cancelled is different and both in City and in Resort Hotel this value is lower in case of cancellation, which means that cancellation usually occurs quite soon after booking. The chances of cancellation are less if sufficient time has elapsed from the date of booking.

```{r warning=FALSE}
# Boxplot to show cancellations based on lead_time
ggplot(data = hotel_bookings_new, aes(x=is_canceled, y=lead_time, fill=is_canceled))+
  geom_boxplot(position = position_dodge() ) +
  labs(
    title = "Cancellation By Hotel Type Based on Lead Time",
    x = "Hotel Type",
    y = "Lead Time (Days)"
  ) +
  scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled","Cancelled" )
  ) + theme_bw() +
  facet_wrap(~hotel)
```


All these things can be shown also by the density plot:

```{r warning=FALSE}
ggplot(hotel_bookings_new, aes(x = lead_time, fill = is_canceled)) + 
  geom_histogram(aes(y = ..density..), position = position_dodge(), binwidth = 20 ) +
  geom_density(alpha = 0.2) + 
  labs(title = "Average Daily rate by Hotel",
       x = "Lead Time",
       y = "Count") + scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled","Cancelled" )) + 
  xlim(0,500) +
  theme_bw() + theme(legend.position = "top")
```

As stated before out of all the bookings, the majority of requests is for City Hotel (about 65% of the total bookings) and from the plot we can see that the percentage of confirmed status is higher than cancellations in both cases. In particular the ratio between canceled and not canceled is lower in case of Resort, which means that those who book a resort have a lower tendency to cancel their booking.

```{r warning=FALSE}
# Percentage of cancellations for hotel type
ggplot(data = hotel_bookings_new,
       aes(
         x = hotel,
         y = prop.table(stat(count)),
         fill = factor(is_canceled),
         label = scales::percent(prop.table(stat(count)))
       )) +
  geom_bar(position = position_dodge()) +
  geom_text(
    stat = "count",
    position = position_dodge(.9),
    vjust = -0.5,
    size = 3
  ) +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "Cancellation Status by Hotel Type",
       x = "Hotel Type",
       y = "Count") +
  theme_classic() +
  scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled", "Cancelled")
  ) + theme_bw()
```


The following result is very interesting: the plot shows the number of cancellations for different types of deposit that a customer can made to guarantee the booking. Most of the time no deposit is required, but the main observation here is that if the deposit is not recoverable the number of cancellations becomes way higher than the number of confirmed bookings. In the plot a log scaling was applied on the y-axis to better show the difference among cancellations in the Non Refundable case (without the scaling the number of non cancelled reservations was so small that it could be barely seen).

```{r warning=FALSE}
# This plot shows the number of bookings per deposit_type
ggplot(hotel_bookings_new, aes(deposit_type, fill = is_canceled)) + 
  geom_bar(stat = "count", position = position_dodge()) + 
  labs(title = "Number of bookings for deposit type",
       x = "deposit_type",
       y = "Log(count)") +
  theme_bw() +
         scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled", "Cancelled") ) + scale_y_continuous(trans='log2')
```


```{r warning=FALSE}
  # how people do reservations (distribution channel) and if the cancel it
ggplot(data = hotel_bookings_new, aes(distribution_channel,fill=is_canceled))+
  geom_bar(stat = "count", position = position_dodge()) +
  labs(
    title = "How people do reservations"
  ) +
  theme(axis.text.x=element_text(angle = 40 )) +
  scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled", "Cancelled")) +
  facet_wrap(~hotel) + theme_bw()
```


```{r warning=FALSE}
# days in waiting list
hotel_bookings_new%>%
  filter(days_in_waiting_list>1)%>%
  ggplot(aes(x=days_in_waiting_list,fill=is_canceled))+
  geom_histogram(binwidth = 10) +
  labs(title="Number of days in waiting list before confirmation")+
   scale_fill_manual(values=c("#7fd8be", "#d87f99"),
    name = "Booking Status",
    breaks = c("0", "1"),
    labels = c("Not Cancelled", "Cancelled")
  ) + theme_bw()
```

```{r warning=FALSE}
gg=hotel_bookings_new%>%
  mutate("children_or_babies"=(ifelse((children>0 | babies>0), "Yes", "No")))%>%
  mutate("baby"=(ifelse(babies>0, "Yes", "No")))%>%
  mutate("child"=(ifelse(children>0, "Yes", "No")))

ggplot(gg, aes(x = lead_time, fill = children_or_babies)) + 
  geom_density(alpha = 0.4) + 
  labs(title = "Lead Time by presence of children or babies",
       x = "Lead Time",
       y = "Count") +
  xlim(0,500)+
  theme_bw() + theme(legend.position = "top")

ggplot(gg, aes(x = lead_time, fill = baby)) + 
  geom_density(alpha = 0.4) + 
  labs(title = "Lead Time by presence of babies",
       x = "Lead Time",
       y = "Count") +
  xlim(0,500)+
  theme_bw() + theme(legend.position = "top")

ggplot(gg, aes(x = lead_time, fill = child)) + 
  geom_density(alpha = 0.4) + 
  labs(title = "Lead Time by presence of children",
       x = "Lead Time",
       y = "Count") +
  xlim(0,500)+
  theme_bw() + theme(legend.position = "top")
 ```

# Measures of association between variables 

Most of the variables in our dataset are categorical. Therefore, we decided to differentiate the association analysis between numerical variables and between categorical variables. 

## Association between numerical variables - Correlation

Usually, when we want to understand the relationship between two variables we immediately think of correlation. We know, however, that this is used to refer only to a linear relationship between two variables, and so we have to consider only numerical variables. Therefore, we made the following correlation matrix with all the numerical variables. 

```{r}
# Correlation matrix

hotel_numerical <- as.data.frame(hotel_bookings_new[,c("lead_time", "stays_in_weekend_nights", "stays_in_week_nights", "adults", "children", "babies", "days_in_waiting_list", "adr", "previous_cancellations", "previous_bookings_not_canceled", "booking_changes", "required_car_parking_spaces", "total_of_special_requests")]) 

cor_mat <- cor(hotel_numerical)

corrplot(cor_mat)
```
As we can see from the corrplot, the numerical variables are not correlated.


## Association between categorical variables - Chi-square

Since there is not really a best way to describe the association between two different categorical variables, we decided to focus on associations between the variable *is_canceled* and the other categorical variables. In general, the most used method in this case is the Chi-square, and in particular the Cramer's V, which is a normalized version of the Chi-square statistics.

We start from the couple *is_canceled*/*market_segment*:

```{r warning=FALSE}
# Is_canceled - market segment

canceled_market <-table(hotel_bookings_new$is_canceled, hotel_bookings_new$market_segment)
canceled_market
```

```{r warning=FALSE}
# Chi-square is_canceled - market segment

cs_market <-chisq.test(canceled_market, correct = FALSE)
cs_market
```

```{r}
# Cramer's V is_canceled - market segment

cramersv(cs_market)
```

A second case is that of *is_canceled*/*deposite_type*:

```{r warning=FALSE}
# Is_canceled - deposite_type

canceled_deposit <-table(hotel_bookings_new$is_canceled, hotel_bookings_new$deposit_type)
canceled_deposit
```

```{r warning=FALSE}
# Chi-square is_canceled - market segment

cs_deposit <-chisq.test(canceled_deposit, correct = FALSE)
cs_deposit
```

```{r}
# Cramer's V is_canceled - market segment

cramersv(cs_deposit)
```

Furthermore a Chi-square test is conducted on the variable *arrival_date_month*, because it is a multilevel categorical variable that shows a large number of levels (12) with respect to the others. It is he only time variable we will use in the definition of the predictive model (since it is in our view the most relevant one according to the aim of this project, while informations about days of arrival are too specific and that about year of arrival too generic). For these reasons particular attention has been paid to it.

```{r warning=FALSE}
# Is_canceled - arrival_date_month

canceled_month <-table(hotel_bookings_new$is_canceled, hotel_bookings_new$arrival_date_month)
canceled_month
```

```{r warning=FALSE}
# Chi-square is_canceled - arrival_date_month

cs_month <-chisq.test(canceled_month, correct = FALSE)
cs_month
```

```{r}
# Cramer's V is_canceled - arrival_date_month

cramersv(cs_month)
```

In all these three cases considered above, the value is really close to zero, which means that our variables are very unlikely to be completely un-associated in some population. However, this does not mean the variables are strongly associated; a weak association in a large sample size may also result in a p-value close to zero. Furthermore, we know that when Cramer's V is 0, it indicates no association between the two variables, while Cramer's V equal to 1 means a strong association; in the intermediate cases it is difficult to interpret, because the value also depends on the size of table and many other things. For these reasons, since in the particular case of 2x2 tables there exist other association measures, we considered them.


## Models

Starting from the informations provided by the initial dataset, a first logistic regression model has been implemented, after removing variables with too many missing values (*agent* and *company*, as stated before). We already pointed out in the previous section that some other variables tend to be redundant; this is the case of *market_segment* and *reservation_status*: for this reason they are discarded from the further analysis.
All the remaining variables are included in the initial model, which is called the *complete model*. At this point it’s important to emphasize that a variable has been added artificially to the dataset: it is *total_stays*, which is the sum of two variables in the dataset, *stays_in_weekend_nights* and *stays_in_week_nights* and it represents the total duration of the client’s stay.

Since most of the variables we are dealing with are categorical, the function *lm* (i.e. linear model) provided by *r* had to be replaced with the more general *glm* (i.e. generalized linear model). As argument, the hyper-parameter *family* was set to “binomial”, because the response variable *is_canceled* is binary (values: 0,1).

```{r, warning=FALSE}
complete_model<-glm(is_canceled~hotel+lead_time+reservation_status_date+arrival_date_month+total_stays+adults+children+babies+meal+distribution_channel+is_repeated_guest+adr+previous_cancellations+previous_bookings_not_canceled+booking_changes+deposit_type+days_in_waiting_list+customer_type+required_car_parking_spaces+total_of_special_requests,  family="binomial")
summary(complete_model)
```


The model output shows that most of the variables are significant, but some of them, like *children*, *babies* and *required_car_parking_space*, are surprisingly not significant, which means that the number of children or babies and the presence of a car parking are not relevant, in this linear model, in order to predict if a customer will cancel the reservation.
We can compute the confusion matrix:

```{r, warning=FALSE}
logistic.prob_complete <- predict(complete_model, type="response")
logistic.pred_complete <- rep(0, length(logistic.prob_complete))
logistic.pred_complete[logistic.prob_complete > 0.5] <- 1
table(logistic.pred_complete, hotel_bookings_new$is_canceled)
```


And finally the ROC curve:

```{r}
# ROC Curve

roc.out_complete <- roc(hotel_bookings_new$is_canceled, logistic.prob_complete, levels=c(0, 1)) 
plot(roc.out_complete,  print.auc=TRUE, legacy.axes=TRUE, xlab="False positive rate", ylab="True positive rate", col="red") 
```


At the beginning the idea was to use the function *regsubset* to perform model selection, but we soon find a serious problem: this function splits categorical variables in their levels and treats each of them as a dummy variable, which means that one of the levels could be found significant and then kept, while other levels of the same variable could be discarded. This is a serious issue when working with categorical variables. A good solution could be to use methods such as *force.in* or *force.out* to force some variables to be entirely in the model or entirely discarded. This strategy was not really helpful in this case, where almost all the variables are categorical and the use of such a method would drove us to hold them all, since at least some of levels for each variable turned out to be significant. It was also not clear how to perform the selection manually, since *glm* function does not return rates like *R* or the adjusted *R^2*.

So we decided to implement the function *stepAIC*, that takes as input the complete model and adds or removes progressively variables according to the hyper-parameter *direction* (typical values are *backward*, *forward* or *both*) so to try different combinations of predictors. The *direction* value was set to *both* (i.e. both *forward* and *backward*). The *stepAIC* function computes for each submodes the AIC, which is an estimator of prediction error and finally returns the model with the lowest AIC at each iteration and the correspondent AIC value.

```{r warning=FALSE}
model_AIC<-stepAIC(complete_model, direction = "both")
```


The best model in our analysis turned out to be the complete model without *babies*, which fits in perfectly with the fact that *babies* has been recognized as non-significative in the first regression we performed on the complete model.
We can see from the results that the difference in terms of AIC among the complete model and the one retrieved by the *stepAIC* function is minimal:

AIC_complete = 104011.4
AIC_not-babies = 104009.8

For an assessment of the models the AUC parameter has been chosen. This is an acronym for Area Under Curve and it provides a view on the overall performance of a classifier, summarized over all possible thresholds. The curve we refer to in this description is the ROC, that allows us to display the True Positive Rates (also called *Sensitivity*) and the False Positive Rates for all possible thresholds.

```{r, warning=FALSE}
logistic.prob_AIC=predict(model_AIC, type="response")
logistic.pred_AIC <- rep(0, length(logistic.prob_AIC))
logistic.pred_AIC[logistic.prob_complete > 0.5] <- 1
table(logistic.pred_AIC, hotel_bookings_new$is_canceled)
```


As can be seen from the plot, the ROC curve is almost exactly the same for our best models, which are the complete model and the complete one without babies. All the other curves corresponding to different models checked by the *stepAIC* function turn out to have a smaller AUC value, which implies a worse overall performance.
An important remark is that AIC rate generally favors models with less variables. For this reason, even if in the end the two models are equivalent, the one without *babies* is to be preferred according to AIC rate.

```{r}
# ROC Curve

logistic.prob_AIC=predict(model_AIC, type="response")
roc.out_AIC <- roc(hotel_bookings_new$is_canceled, logistic.prob_AIC, levels=c(0, 1)) 
plot(roc.out_AIC,  print.auc=TRUE, legacy.axes=TRUE, xlab="False positive rate", ylab="True positive rate", col="red") 
  
```

### RIDGE

```{r}
x <- model.matrix(is_canceled~lead_time+reservation_status_date+arrival_date_month+total_stays+adults+children+babies+meal+distribution_channel+is_repeated_guest+adr+previous_cancellations+previous_bookings_not_canceled+booking_changes+deposit_type+days_in_waiting_list+customer_type+required_car_parking_spaces+total_of_special_requests, hotel_bookings_new)[,-1]
y <- hotel_bookings_new$is_canceled

#Ridge plots
grid <- 10^seq(10, -2, length=100)
ridge.mod <- glmnet(x, y, alpha=0, family="binomial", lambda=grid)
plot(ridge.mod, label=TRUE)
plot(ridge.mod, xvar="lambda", label=TRUE)
grid[65:75]
predict(ridge.mod, s=50, type="coefficients")

#Ridge on train set
train <- sample(1:nrow(x), nrow(x)/2)
test <- (-train)
y.test <- y[test]

ridge.mod <- glmnet(x[train, ], y[train], alpha = 0, family="binomial",
                    lambda = grid, thresh = 1e-12)

ridge.pred <- predict(ridge.mod, s = 4, newx = x[test, ], type="response")
predicted.classes <- ifelse(ridge.pred > 0.5, "1", "0")
confusionMatrix(y.test, as.factor(predicted.classes))

#Cross-validation to choose lambda 
set.seed(1)
cv.out <- cv.glmnet(x[train, ], y[train], alpha = 0, family="binomial", nfold=10)
cv.out$lambda[1:10]
summary(cv.out$lambda)

cv.out$cvm[1:10]
cv.out$cvsd[1:10]
plot(cv.out)

i.bestlam <- which.min(cv.out$cvm)
#i.bestlam 
bestlam <- cv.out$lambda[i.bestlam]
#bestlam
cv.out$cvm[i.bestlam]
#min(cv.out$cvm)

bestlam <- cv.out$lambda.min
cat("Best lambda is:", bestlam)

#Ridge with best lambda
ridge.pred <- predict(ridge.mod, s = bestlam,
                      newx = x[test, ])
#Evaluation
predicted.classes <- ifelse(ridge.pred > 0.5, "1", "0")
confusionMatrix(y.test, as.factor(predicted.classes))
```

### LASSO

```{r}
lasso.mod <- glmnet(x,y,alpha=1, family="binomial", lambda=grid)
plot(lasso.mod, label=TRUE)
plot(lasso.mod, xvar="lambda", label=TRUE)

set.seed(1)
cv.out <- cv.glmnet(x[train,], y[train], family="binomial", alpha=1)
plot(cv.out)
bestlam <- cv.out$lambda.min
cat("Best lambda for Lasso Regression is:", bestlam)
lasso.pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
#Evaluation
predicted.classes <- ifelse(lasso.pred > 0.5, "1", "0")
confusionMatrix(y.test, as.factor(predicted.classes))

```

### Logistic VS LDA VS QDA
```{r}
#Train & Test
set.seed(321)
trainIndex <- createDataPartition(hotel_bookings_new$is_canceled,p=0.75,list=FALSE)
hotel_data_train=hotel_bookings_new[trainIndex,]
hotel_data_test=hotel_bookings_new[-trainIndex,]
is_canc_test=hotel_data_test$is_canceled
```


```{r}
#Logistic Regression
glm.fits <- glm(is_canceled~lead_time+adr+total_of_special_requests,data=hotel_data_train,family=binomial)
glm.probs <- predict(glm.fits,hotel_data_test,type="response")
glm.pred <- rep(0,29847)
glm.pred[glm.probs>.5] <- 1

#Evaluation
confusionMatrix(as.factor(glm.pred),is_canc_test)
cat("Mean error is:", mean(glm.pred!=is_canc_test))
```

```{r}
#Polinomial Regression
glm.fits <- glm(is_canceled~lead_time+adr+total_of_special_requests+I(adr^3)+I(lead_time^2)+I(total_of_special_requests^2),data=hotel_data_train,family=binomial)
glm.probs <- predict(glm.fits,hotel_data_test,type="response")
glm.pred <- rep(0,29847)
glm.pred[glm.probs>.5] <- 1

#Evaluation
confusionMatrix(as.factor(glm.pred),is_canc_test)
cat("Mean error is:", mean(glm.pred!=is_canc_test))
```

```{r}
#LDA
lda.fit <- lda(is_canceled~lead_time+adr+total_of_special_requests,data=hotel_data_train)
par(mar=c(1,1,1,1))
plot(lda.fit)
lda.pred <- predict(lda.fit, hotel_data_test)
lda.class <- lda.pred$class

#Evaluation
confusionMatrix(as.factor(lda.class),is_canc_test)
cat("Mean error is:", mean(glm.pred!=is_canc_test))
```

```{r}
#QDA
qda.fit <- qda(is_canceled~lead_time+adr+total_of_special_requests,data=hotel_data_train)
qda.pred <- predict(qda.fit, hotel_data_test)
qda.class <- qda.pred$class


# Evaluation
confusionMatrix(as.factor(qda.class),is_canc_test)
cat("Mean error is:", mean(glm.pred!=is_canc_test))
```
